#!/bin/bash

# Original code Copyright (c) 2017 Shane Celis[1]
# Licensed under the MIT License[2]
#
# This comment generated by code-cite[3].
#
# [1]: https://twitter.com/shanecelis
# [2]: https://opensource.org/licenses/MIT
# [3]: https://github.com/shanecelis/code-cite

# cite
#
# Generate a citation for code.
#
# Dependencies: bash, curl, jq, mo, and perl


set -ueE -o pipefail;
if ! bin_path=$(readlink "$0"); then
    bin_path="$0";
fi
tracing=0;
if [[ $- =~ x ]]; then
    tracing=1;
fi

bin_dir=$(dirname "$bin_path");

code_cite_link="https://github.com/shanecelis/code-cite"
# stackexchange client id for 'cite-stackoverflow'. Fine to keep as is.
client_id="10102";
client_key="nvTB2XGxj5eWuyeMCmJTJA((";

set +x;
set +e;
source "$HOME/bin/mo";          # XXX This should be packed with code-cite.
set -e;
if [[ $tracing -eq 1 ]]; then set -x; fi
template_dir="$bin_dir/templates/";
template="stackoverflow";
year_modified=""
modifier_name=""
modifier_link=""
license=""
license_name=""
license_link=""
note=""

inline_link_count=0
inline_link() {
    inline_link_count=$((inline_link_count + 1));
    echo $inline_link_count;
}
ref_link_count=0
ref_link() {
    ref_link_count=$((ref_link_count + 1));
    echo $ref_link_count;
}

usage() {
    echo "usage: cite [-hvmMTL] [-u code-url]";
    echo "            [-X author-name]   [-Y year-created]  [-Z author-link]";
    echo "            [-x modifier-name] [-y year-modified] [-z modifier-link]";
    echo "            [-l license] [-N notes] [-p prefix]";
    echo "            [-c config.json] [-t template] [-W pid] [-e eval-string]";
    echo " -h      Show usage.";
    echo " -v      Be verbose.";
    echo " -m      Mark this code as modified.";
    echo " -M      Mark this code as not modified.";
    echo " -N      Make note of something in the message. ";
    echo " -T      List templates";
    echo " -L      List licenses";
    echo " -p      Prefix each line of template with 'prefix', mainly used for alignment.";
}
# https://stackoverflow.com/a/17841619/6454690
function join_by { local IFS="$1"; shift; echo "$*"; }

display_cache_warning() {
    pid=$1;
    keys_used_path=/tmp/cite-stackoverflow/keys-used.$pid;
    # echo "checking $keys_used_path" >&2;
    if [ -f "$keys_used_path" ]; then
    # if [ ${#keys_used[@]} -ne 0 ]; then
        # keys="$(join_by , ${keys_used[@]})";
        if [ $verbose -eq 1 ]; then
            echo "info: Used cache for keys: $(cat $keys_used_path | sort | uniq | tr '\n' ',')" >&2;
        else
            count=$(cat $keys_used_path | sort | uniq | wc -l | xargs); # xargs is working like trim
            echo "info: Used cache for $count stackexchange API requests." >&2;
        fi
        rm "$keys_used_path";
        return 0;
    fi
    return 0;
}

display_answer_warning() {
    pid=$1;
    no_answer_path=/tmp/cite-stackoverflow/no_answers.$pid;
    if [ -f "$no_answer_path" ]; then
        if [ $verbose -eq 1 ]; then
            echo "warning: Answer not specified for following questions: $(cat $no_answer_path | sort | uniq | tr '\n' ',')" >&2;
        else
            count=$(cat "$no_answer_path" | sort | uniq | wc -l | xargs); # xargs is working like trim
            echo "warning: Answer not specified for $count questions." >&2;
        fi
        rm "$no_answer_path";
        return 0;
    fi
    return 0;
}

display_modified_warning() {
    pid=$1;
    modified_path=/tmp/cite-stackoverflow/modified.$pid;
    if [ -f "$modified_path" ]; then
        if [ $verbose -eq 1 ]; then
            echo "warning: not specified whether code was modified for following citations: " >&2;
            cat $modified_path | sort | uniq >&2;
        else
            count=$(cat "$modified_path" | sort | uniq | wc -l | xargs); # xargs is working like trim
            echo "warning: Not specified whether code was modified for $count cases." >&2;
        fi
        rm "$modified_path";
        return 1;
    fi
    return 0;
}

display_warnings() {
    err=0;
    trap - ERR
    set +e;
    display_answer_warning $1;
    let "err|=$?"
    display_cache_warning $1;
    let "err|=$?"
    display_modified_warning $1;
    let "err|=$?"
    set -e;
    return $err;
}

function internal_error() {
    if [ $1 -ne 0 ] && [ $running_backend -ne 1 ]; then
        echo "error: internal script error at ${2}:${3} $4" >&2;
    fi
}

if [ -z "${ROOT_PID-}" ]; then
    export ROOT_PID=$$;
    trap "display_warnings $ROOT_PID " EXIT
fi
# trap 'rc=$?; echo "ERR at line ${LINENO} (rc: $rc)"; exit $rc' ERR
# trap 'rc=$?; echo "EXIT (rc: $rc)"; exit $rc' EXIT
#set -ueE -o pipefail;
# trap '[ $? -ne 0 ] && echo "error: internal script exit at line ${LINENO}." >&2' EXIT
# trap '[ $? -ne 0 ] && echo "error: internal script error at line ${LINENO}." >&2' ERR
# trap 'internal_error $? $LINENO' EXIT
trap 'internal_error $? $BASH_SOURCE $BASH_LINENO "${LASTERR-}"' ERR
running_backend=0;
verbose=0;
modified=0;                     # 2 means it's not clear which
prefix="";
url="";
config_file="$bin_dir/cite-config.json";
stackoverflow_opts="q:a:"
twitter_opts="s:"
github_opts="g:"
opts="hvmMTLu:
X:Y:Z:
x:y:z:
l:N:p:
c:t:W:e:
${stackoverflow_opts}
${twitter_opts}
${github_opts}";
while getopts "$opts" arg; do
    case "$arg" in
        h) usage;
           exit 0;;
        X) author_name="$OPTARG";;
        Y) year_created="$OPTARG";;
        Z) author_link="$OPTARG";;
        x) modifier_name="$OPTARG";;
        y) year_modified="$OPTARG";;
        z) modifier_link="$OPTARG";;
        N) note="$OPTARG";;
        l) license="$OPTARG";;
        L) echo "Licenses available from $bin_dir/licenses.json: ";
           cat "$config_file" | jq -r '.licenses | keys | .[]';
           exit 0;;
        m) modified=1;;
        M) modified=0;;
        v) verbose=1;;
        p) prefix="$OPTARG";;
        c) config_file="$OPTARG";
           if ! [ -f "$config_file" ]; then
               echo "error: no config file found '$config_file'." >&2;
               exit 7;
           fi;;
        e) eval "$OPTARG";;
        u) url="$OPTARG";;
        t) template="$OPTARG";;
        W) display_warnings $OPTARG;
           exit $?;;
        T) echo "Templates available from $template_dir: ";
           (cd $template_dir; echo * | tr ' ' '\n');
           exit 0;;
        \?) usage >&2;
           exit 2;;
        *) # Let this pass thru. It may be options to our backends.
           :;;
    esac
done
# Let's keep the arguments around.
#shift $((OPTIND-1))
declare -a applicable_backends=()
for backend in $bin_dir/backends/*; do
    backend_err=0;
    running_backend=1;
    if [ $verbose -eq 1 ]; then
        if ! output="$($backend ignoreopts "$opts" "$@")"; then
            backend_err=1;
        fi
    else
        if ! output="$($backend ignoreopts "$opts" "$@" 2>/dev/null)"; then
            backend_err=1;
        fi
    fi
    running_backend=0;
    if [ $backend_err -eq 0 ]; then
        applicable_backends+=( $(basename "$backend") );
        if [ $verbose -eq 1 ]; then
            echo "info: using $(basename $backend) as backend." >&2;
            echo "backend output:" >&2;
            echo "$output" >&2;
        fi
        eval "$output";
        # break;
    fi
done
if [ "${#applicable_backends[@]}" -gt 1 ]; then
    echo "warning: multiple backends would work: " >&2;
    for b in "${applicable_backends[@]}"; do
        echo $b >&2;
    done
elif [ "${#applicable_backends[@]}" -eq 0 ]; then
    echo "warning: no backends worked." >&2;
fi

if cat "$config_file" | jq -e ".contributors.${author_name}" > /dev/null; then
    if [ -z "${author_link-}" ]; then
        author_link=$(cat "$config_file" | jq -r ".contributors.${author_name}.link");
    fi
    author_name=$(cat "$config_file" | jq -r ".contributors.${author_name}.name");
fi

if [ -z "$license_name" ]; then
    license_name=$(cat "$config_file" | jq -r ".licenses.${license:-none}.name");
fi
if [ -z "$license_link" ]; then
    license_link=$(cat "$config_file" | jq -r ".licenses.${license:-none}.link");
fi

if [ $modified -eq 2 ]; then
    # echo "warning: assuming the code has not been modified." >&2;
    modified_path=/tmp/cite-stackoverflow/modified.$ROOT_PID;
    echo "$(basename $0) $*" >> "$modified_path";
    modified=0;
fi

if [ $modified -eq 1 ]; then
    if [ -z "$modifier_name" ]; then
        echo "error: no modifier_name given.  Use -n." >&2;
        usage >&2;
        exit 5;
    fi
    if [ -z "$modifier_link" ]; then
        echo "error: no modifier_link given.  Use -U." >&2;
        usage >&2;
        exit 6;
    fi
    if [ -z "$year_modified" ]; then
        echo "error: no year_modified given.  Use -y." >&2;
        usage >&2;
        exit 6;
    fi
else
    modifier_name="";
    modifier_link="";
    year_modified="";
fi
# Add prefix (usually whitespace), but don't add it if the line is blank.
#prefix_length=$(echo -n "$prefix" | wc -c)
# Folding had a couple issues:
# 1. It'd fold the URLs.
# 2. It'd fold without adding enough spaces to have the text flush.
#mo "$template" | fold -sw $((80 - prefix_length)) | perl -pe "s/^(?=\s*\S)/$prefix/g;";
if [ -f "$template_dir/$template" ]; then
    set +xueE;
    if ! mo --fail-not-set "$template_dir/$template" | perl -pe "s/^(?=\s*\S)/$prefix/g;"; then
        set -ueE;
        if [[ $tracing -eq 1 ]]; then set -x; fi
        echo "error: running template." >&2;
        #cat "$template_dir/$template" >&2;
        :
        exit 1;
    else
        set -ueE;
        if [[ $tracing -eq 1 ]]; then set -x; fi
        exit 0;
    fi

else
    echo "error: no template $template_dir/$template" >&2;
    exit 9;
fi
